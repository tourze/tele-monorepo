---
name: method-nplus1-guardian
description: 防止与修复 N+1 查询问题，覆盖检测方法、重构策略与回归验证。
---

# N+1 守护技能

## 适用场景
- 代码评审或性能监控发现疑似 N+1。
- 新增查询、API、列表页时需要预防 N+1。
- 进行性能优化、容量评估、数据库重构。

## 前置准备
- 获取相关代码、查询日志、监控指标。
- 在本地或预发环境开启 SQL 日志/Profiler。
- 明确业务场景（列表项数量、分页策略、缓存情况）。

## 操作步骤
1. **检测**
   - 开启 ORM 调试日志（Doctrine DebugStack、Eloquent debugbar）。
   - 使用测试或脚本模拟典型数据量，记录 SQL 次数。
   - 在数据库开启 `slow_query_log` 或使用 APM 追踪。
2. **判定**
   - 若循环中发起数据库请求，即判定为 N+1。
   - 评估查询次数随数据量线性增长的情况。
3. **修复策略**
   - **预加载**：Doctrine `->with('relation')`、Eloquent `with`、TypeORM `leftJoinAndSelect`。
   - **批量查询**：使用 `IN` 查询、`DataLoader`。
   - **缓存**：读多写少的场景采用本地缓存或分布式缓存。
   - **重构数据结构**：调整接口返回数据、增加聚合表。
4. **验证**
   - 重跑性能测试，确认 SQL 数量明显减少。
   - 记录优化前后耗时、CPU、IO 指标。
   - 补充回归测试防止复发。
5. **监控**
   - 为关键接口设置查询次数、耗时阈值。
   - 将 N+1 检测融入质量门（静态扫描、测试断言）。

## 质量校验
- 优化后 SQL 次数稳定且与数据量无线性增长。
- 性能指标改善（响应时间、CPU、DB 负载）。
- 测试覆盖 N+1 风险路径，质量门通过。

## 失败与回滚
- 预加载导致内存飙升：分批加载或分页。
- 批量查询破坏事务隔离：引入悲观锁或拆分操作。
- 缓存一致性风险：增加失效策略、回源兜底，必要时回滚。

## 交付物
- 优化方案说明：前后 SQL 对比、性能指标。
- 回归测试与监控配置。
- 后续观察项与改进计划。
