---
name: method-parallel-task-coordination
description: 指导复杂任务的并行化拆分、依赖识别、冲突处理与调度优化。
---

# 并行任务协调技能

## 适用场景

- 存量代码质量问题 > 50 个，需要分批并行处理。
- 多个独立模块需要同步修复或重构。
- 使用子代理（Task 工具）执行并行任务，需要优化调度策略。

## 前置准备

- 识别任务总量与类型（依赖声明、风格、类型、复杂度等）。
- 分析任务间依赖关系（无依赖可并行，有依赖需串行）。
- 评估资源限制（子代理数量、执行时间、工具访问权限）。

## 操作步骤

### 1. 任务分类与依赖分析

- **无依赖任务**：可以完全并行执行
  - 示例：风格治理（empty()、短三元）和依赖声明补齐
  - 示例：不同模块的独立功能开发
- **弱依赖任务**：可以并行但需要最终合并验证
  - 示例：弃用 API 更替和类型声明修复（同属批次二，互不影响）
  - 示例：不同组件的测试补充
- **强依赖任务**：必须串行执行
  - 示例：风格修复 → 类型修复 → 复杂度重构（后者依赖前者稳定）
  - 示例：数据库迁移 → 应用代码更新

### 2. 批次划分策略

**批次化模板（存量质量问题）**：

```markdown
批次一：基础设施与风格
  - 任务A：依赖声明补齐（独立）
  - 任务B：风格治理（独立）
  ✅ 可并行：无依赖，互不影响

批次二：类型系统修复
  - 任务A：弃用 API 更替（独立）
  - 任务B：类型声明修复（独立）
  ✅ 可并行：同层级，无交叉

批次三：结构重构
  - 任务：复杂度降低（按优先级串行）
  ❌ 需串行：依赖批次一二稳定，高风险需谨慎

批次四：测试补齐
  - 任务：补充缺失测试
  ⚠️ 弱依赖：可与批次三部分并行，但需最终统一验证

批次五：最终校准
  - 任务：更新测试断言、集成验证
  ❌ 需串行：依赖所有前序批次完成
```

**三阶段批量修复模式（🔥 新增经验）**：

适用于存量代码质量治理（> 100个错误），重点关注类型安全问题：

```markdown
阶段一：核心业务逻辑修复（并行度 3）
  - 任务A：Command层 - API响应处理和类型安全
  - 任务B：Service层 - 业务逻辑类型修复
  - 任务C：Listener层 - 事件监听器类型安全
  ✅ 可并行：不同文件，处理同类问题
  🎯 目标：解决核心业务逻辑的类型安全问题

阶段二：测试基础设施修复（并行度 1）
  - 任务A：测试基类统一、泛型类型声明
  - 任务B：Request测试类继承问题
  ✅ 独立：无依赖冲突，影响测试框架
  🎯 目标：建立稳定的测试基础设施

阶段三：测试数据类型安全（批量修复）
  - 任务：数组访问安全、测试断言增强
  ✅ 批量：相似错误模式，统一修复策略
  🎯 目标：消除所有测试相关类型错误

最终验证：0错误目标 + 100%测试通过
```

**模式特点**：

- **效率导向**：阶段一采用3个并行任务，效率提升约40%
- **风险控制**：核心业务逻辑优先，测试基础设施为辅
- **质量保证**：每阶段完成立即验证，最终达到0错误目标
- **适用场景**：PHPStan错误 > 100个，包含复杂度问题的综合修复

**实战案例**：wechat-work-intercept-rule-bundle（137个错误 → 0个错误）

- 阶段一：3个并行任务修复110个类型安全错误
- 阶段二：修复20个测试基础设施问题
- 阶段三：批量处理7个复杂度+测试数据问题

### 3. 并行度控制

**并行度建议**：

- **2 个并行任务**：适合无依赖的简单任务（风格、依赖）
- **3-4 个并行任务**：适合中等复杂度、明确边界的任务
- **> 4 个并行任务**：需要评估冲突风险和资源消耗

**冲突识别**：

- 文件级冲突：多个任务修改同一文件的不同部分
- 工具级冲突：并发调用同一工具（如 PHPStan、git）
- 资源级冲突：内存、CPU、网络带宽竞争

### 4. 调度与同步

**启动并行任务**：

```markdown
使用单个消息发送多个 Task 工具调用：
- Task 1: 批次一A - 依赖声明
- Task 2: 批次一B - 风格治理

等待两个任务完成，收集结果，再启动批次二。
```

**任务完成检查**：

- 确认所有并行任务返回结果
- 检查是否有任务失败或部分完成
- 合并修改前运行冲突检测（git status、文件 diff）

**验证时序设计（🔥 关键经验）**：

```markdown
并行任务完成后必须执行的验证流程：
1. **立即整体验证**：不要等待，马上运行质量门
2. **业务逻辑保护检查**：确保功能性未被破坏
3. **回归测试验证**：运行完整测试套件，确保0回归
4. **问题快速修复**：发现问题立即修复，不要累积
```

**合并策略**：

- 并行任务完成后，按顺序合并修改
- 每次合并后运行质量门验证
- 发现冲突时，优先保留高优先级任务的修改
- **业务逻辑优先**：冲突时优先保护业务健壮性而非代码清洁度

### 5. 失败处理

**单个任务失败**：

- 记录失败原因和影响范围
- 评估是否阻塞其他任务
- 决定是否重试、降级或跳过

**多个任务冲突**：

- 使用 git diff 或文本对比识别冲突点
- 手动合并或选择回滚冲突方
- 记录冲突解决方案，避免未来重复

**业务逻辑破坏应急处理（🔥 新增经验）**：

```markdown
当发现并行任务破坏了业务逻辑时：
1. **立即停止**：暂停所有后续任务
2. **快速诊断**：确定影响范围和根因
3. **业务优先修复**：恢复必要的异常处理和逻辑
4. **重新验证**：确保业务功能完全恢复
5. **流程优化**：更新指令模板，防止重复
```

## 质量校验

- 并行任务间无文件级冲突。
- 所有任务完成后运行完整质量门，无回归。
- 并行度控制在合理范围（< 5），资源消耗可控。
- 任务执行记录完整，包含时间、结果、冲突处理。
- **业务逻辑完整性**：确保所有修改不破坏现有功能（🔥 新增）。
- **验证时序合规**：并行任务后必须立即进行整体验证（🔥 新增）。

## 失败与回滚

- 并行度过高导致频繁冲突：降低并行度，增加串行步骤。
- 任务依赖分析错误：回滚到安全点，重新分析依赖关系。
- 资源限制导致任务超时：减少并行任务数，或增加单任务超时时间。

## 交付物

- 任务依赖关系图（Mermaid 流程图或表格）。
- 批次划分计划与并行度配置。
- 任务执行记录（时间、状态、冲突、解决方案）。
- 并行调度优化建议（基于本次经验）。

## 最佳实践

### ✅ 推荐做法

1. **明确批次边界**：每个批次有清晰的目标和验证标准
2. **保守并行**：不确定时优先串行，避免返工
3. **增量验证**：每批次完成后运行质量门，不要等到最后
4. **记录依赖**：在计划中显式标注任务间的依赖关系
5. **业务优先原则**：代码清洁度不能影响业务健壮性（🔥 新增）
6. **立即验证流程**：并行任务完成后必须马上进行整体验证（🔥 新增）

### ❌ 避免做法

1. **过度并行**：超过 5 个并行任务，管理成本大于收益
2. **依赖模糊**：没有分析清楚依赖就启动并行
3. **延迟验证**：等所有任务完成后才验证，发现问题成本高
4. **忽略冲突**：并行任务完成后没有检查文件冲突
5. **指令不精确**：子代理任务描述缺乏业务逻辑保护约束（🔥 新增）
6. **过度信任子代理**：缺乏中间验证环节，导致问题发现延迟（🔥 新增）

## 示例：批量修复 118 个 PHPStan 错误

### 任务分析

- 依赖声明：1 个错误，独立
- 风格问题：8 个错误（empty、短三元），独立
- 弃用 API：13 个错误，独立
- 类型问题：18 个错误，独立
- 复杂度：7 个文件，有优先级顺序
- 测试覆盖：若干，依赖代码稳定

### 批次划分

```markdown
批次一：基础（并行度 2）
  - 任务A：补齐依赖（1 个错误）✅ 并行
  - 任务B：风格治理（8 个错误）✅ 并行

批次二：类型（并行度 2）
  - 任务A：弃用 API（13 个错误）✅ 并行
  - 任务B：类型声明（18 个错误）✅ 并行

批次三：复杂度（串行）
  - 优先级 1：ControllerTestRule ❌ 串行
  - 优先级 2：BatchActionTestRule ❌ 串行
  - 优先级 3-7：其他 5 个文件 ✅ 可并行

批次四：跳过（评估后决定）

批次五：最终校准（串行）
```

### 执行结果

- 批次一和二使用并行，效率提升 ~40%
- 批次三高优先级串行，降低风险
- 总错误从 118 降至 73（-38%）
- 无冲突，无返工

## 示例：hotel-agent-bundle PHPStan注释修复（🔥 最新经验）

### 任务背景

- **目标**：清理5个无效的@phpstan-ignore注释
- **约束**：使用集成测试，业务优先第一原则
- **特点**：独立文件修复，适合并行处理

### 批次划分（单批次并行）

```markdown
批次一：注释清理（并行度 4）
  - 任务A：OrderItem.php - 清理无效@phpstan-ignore-line
  - 任务B：AgentCrudControllerTest.php - 清理2个无效注释
  - 任务C：AgentHotelMappingCrudControllerTest.php - 清理1个无效注释
  - 任务D：TestKernel.php - 修正错误规则标识符
  ✅ 全部并行：独立文件，无依赖冲突
```

### 执行过程与问题

1. **并行执行**：4个子代理同时处理不同文件
2. **问题发现**：OrderItem的try-catch被错误删除，导致测试失败
3. **快速响应**：5分钟内识别问题并恢复业务逻辑
4. **最终验证**：PHPStan 5→0错误，测试1722个全通过

### 关键经验

- **指令精度关键**：需要明确"保留业务逻辑"的边界条件
- **立即验证必要**：并行任务后必须马上整体验证
- **业务优先决策**：遇到冲突时优先保护功能性

### 最终结果

- **质量目标**：PHPStan错误5→0个（-100%）✅
- **测试状态**：1722个测试通过，0回归✅
- **效率提升**：并行处理节省约40%时间✅
- **提交记录**：4d931da6da，4个文件修改✅

### 经验总结
>
> **核心教训**：静态分析清洁度不能影响业务健壮性，子代理指令必须包含业务逻辑保护约束。

## 任务指令模板（🔥 新增）

### PHPStan注释修复标准指令

```markdown
修复 [文件路径] 中的PHPStan注释问题。

具体任务：
1. **识别无效注释**：查找没有对应错误的@phpstan-ignore注释
2. **保护业务逻辑**：保留所有必要的异常处理和逻辑代码
3. **精确清理**：只删除确实无效的注释，不要修改代码逻辑
4. **验证语法**：确保修改后代码语法正确

重要约束：
- **禁止删除try-catch块**，即使没有PHPStan错误
- **保留异常处理逻辑**，业务健壮性优先于代码清洁度
- **不确定时保留**：有疑问的代码逻辑不要修改

完成后报告具体修改内容和保留的异常处理逻辑。
```

### 通用并行修复指令框架

```markdown
并行修复 [目标路径] 的 [问题类型]。

任务边界：
- 只处理明确指定的文件和问题类型
- 保留所有业务逻辑和异常处理
- 不进行额外的重构或优化

验证要求：
- 修改后代码必须能通过语法检查
- 不能破坏现有功能
- 不确定时选择保守处理

报告内容：
- 具体修改的文件和行数
- 遇到的不确定点和处理方式
- 是否有需要人工介入的复杂情况
```

### 指令关键要素清单

- [ ] **明确任务边界**：具体的文件和问题类型
- [ ] **业务逻辑保护**：明确保留哪些代码
- [ ] **验证标准**：修改后的检查要求
- [ ] **不确定时策略**：遇到疑问时的处理原则
- [ ] **报告要求**：需要返回的具体信息
