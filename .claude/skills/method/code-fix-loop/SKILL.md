---
name: method-code-fix-loop
description: 当需要在多语言项目中执行“定位→分析→修复→回归→复盘”的缺陷治理闭环时，请加载本技能。
allowed-tools: Read(*), Write(*), Edit(*), MultiEdit(*), Bash(*), Glob(*), Grep(*), TodoWrite
---

# 通用修复循环

## 适用场景

- 任意语言、框架、平台下的缺陷修复、代码质量问题处理。
- 质量门或监控发现异常，需要快速定位与闭环。
- 多人协作修复，需要统一流程、记录证据与回滚方案。

## 原则

1. **业务优先**：先确认缺陷对业务的真实影响，必要时建立临时护栏或降级方案。
2. **证据驱动**：每一步都需收集日志、复现脚本或测试结果，杜绝凭印象改动。
3. **迭代收敛**：定位、分析、修复、验证形成循环，直至风险清零。
4. **技能协同**：本技能仅涵盖通用流程，涉及语言/框架/工具时，需追加加载对应技能并引用推荐命令。
5. **记录可追溯**：在 Runbook 或沟通摘要中记录结论、命令、残留风险与回滚预案。
6. **并行协同**：识别到多问题或宏观批次时，必须规划子任务并利用子代理/多任务并行推进，保持任务池透明。
7. **问题清零**：定位或分析阶段发现的所有问题都需纳入闭环处理，禁止遗留或等待额外确认。

## 前置准备

- 收集缺陷的最小复现材料（日志、报错栈、截图、报表链接），并确认问题影响范围。
- 预先列出可用资源：相关代码仓库、配置中心、监控面板、实验平台、用例集合。
- 检查已触发的质量门或报警阈值，确认是否需要立即启用降级或限流类临时护栏。
- 约定协作方式：责任人、沟通频道、并行子任务以及需要通知的干系人。

## 操作步骤

1. **定位问题**
   - 收集上下文（日志、监控、用户反馈、CI 报告）。
   - 在同一轮列出定位 Todo，并立即执行首个取证动作；调用合适的工具技能（如 `git` 取证、日志分析）。
2. **分析根因**
   - 结合代码阅读、历史记录、配置差异等手段收敛根因假设。
   - 若存在多种可能，按影响优先级逐一验证，必要时调用 Codex MCP 获取第二视角。

### Codex MCP 协作触发条件

在以下情况下必须先触发 Codex MCP 协作( `scenario-codex-mcp-collaboration` )，禁止直接放弃或登记 Issue：

| 触发条件 | 具体场景 | 期望输出 |
|---------|---------|---------|
| **把握度<80%** | 多个可行方案无法裁决 | 方案优劣对比与建议 |
| **技术决策冲突** | 规则要求vs实现可行性矛盾 | 权衡分析与最佳实践 |
| **复杂根因分析** | 跨模块/语言特性/框架限制 | 根因确认与验证思路 |
| **设计模式选择** | 继承vs组合/抽象vs具体 | 设计建议与影响评估 |
| **反复修改失败** | 同一问题尝试3次仍未解决 | 新视角与替代方案 |

**协作流程**:

1. 构造提问框架(上下文→问题→备选方案→期望)
2. 调用`codex`或`codex-reply`获取建议
3. 验证建议可行性(通过实验或小范围测试)
4. 记录协作过程与采纳理由
5. 若协作建议仍无法落地，记录验证结果与受阻原因，方可登记 GitHub Issue 作为最终兜底

### 并行推进要求

1. 按照 `method-parallel-task-coordination` 规划批次与任务队列，明确并行粒度、依赖关系与验收口径。
2. 在命中多个问题时，立即创建子代理或多任务执行器，并在各轮总结中同步进度、风险与剩余行动。
3. 并行任务完成后需合并验证结果，确保质量门覆盖全部改动；若存在冲突，优先保障业务正确并记录处理策略。

4. **假设验证(实验优先)**
   - 对于涉及语言特性、框架行为、第三方库的修复,先通过最小实验验证假设
   - 使用快速反馈工具:
     - PHP: `php -r '<code>'` 验证反射/类型/trait行为
     - Node: `node -e '<code>'` 验证异步/原型/模块行为
     - Python: `python -c '<code>'` 验证装饰器/元类/作用域
   - 记录实验结果,避免基于猜测进行大规模重构
   - 若实验失败,重新分析根因;若成功,进入修复方案制定

5. **制定修复方案**
   - 基于验证结果明确修复策略、影响范围、验证方式与回滚路径
   - 遵循 `scenario-quality-gates` 规划需要执行的质量门
6. **实施修复**
   - 根据语言/框架加载对应技能（例如 `php-framework-symfony`、`php-tool-phpstan`）执行变更。
   - 按技能推荐命令执行格式化、静态分析、测试，记录输出。
   - 修复过程中新增识别的问题必须纳入当前循环，更新并行任务计划直至全部清零。

**0错误标准（🔥 核心原则）**：

- **严格定义**：所有PHPStan报告的错误都必须修复，包括复杂度警告
- **分类处理**：
  - 类型安全问题（offsetAccess、argument.type等）：必须优先修复
  - 复杂度问题（complexity.functionLike）：通过方法重构解决
  - 风格问题：可通过工具自动修复
- **验收标准**：PHPStan Level 9 检查返回 `[OK] No errors`
- **禁止例外**：不得以"非阻塞性"为由遗留任何错误

**复杂度重构指导**：

重构前准备：

1. 分析方法复杂度来源（嵌套循环、条件分支、职责过多）
2. 设计子方法提取策略，保持单一职责
3. 确保类型签名的精确性，避免引入新错误

重构执行要点：

1. 提取子方法时保持原参数传递方式
2. 使用 assert() 和 @var 注解确保类型安全
3. 重构后立即运行PHPStan验证
4. 保持所有测试通过，确保功能一致性

## 质量校验

- 缺陷有可复现步骤与验证脚本，修复结果附带命令输出。
- 所有质量门按 `scenario-quality-gates` 完成并记录。
- 关键决策（取舍、降级、例外卡）留有审计记录。

## 失败与回滚

- 无法定位根因时，暂停推进，记录尝试路径并升级讨论。
- 修复触发新缺陷或质量门失败，应回滚到上一个稳定状态并重新评估方案。
- 复盘阶段需输出改进措施，沉淀到技能或 Runbook。

## 交付物

- 缺陷定位记录：复现步骤、证据链、根因分析结论与受影响范围。
- 修复方案与执行日志：代码/配置 diff、实验记录、质量门执行结果。
- 回滚与兜底方案：Kill Switch、回滚脚本、监控报警确认。
- 复盘总结与行动项：经验沉淀、流程改进建议、后续跟踪任务。
