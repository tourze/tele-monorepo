---
name: scenario-codex-mcp-collaboration
description: 规范使用 Codex MCP 工具进行协作，涵盖触发条件、提问框架、会话记录与验证流程。
---

# Codex MCP 协作技能

## 适用场景
- 结论把握低于 80%，需要第二视角验证关键决策。
- 涉及跨模块、高风险变更或复杂假设，需要额外论证。
- 工具或权限受限、信息缺口明显，需要借助 Codex MCP 获取线索。

## 前置准备
- 确认当前环境已注册 `mcp__codex__codex` 与 `mcp__codex__codex-reply` 工具，或记录不可用原因。
- 梳理待解决的问题，明确期望 Codex 返回的输出格式与质量门。

## 提问框架模板

构造 Codex MCP 提问时，建议包含以下结构：

### 上下文
- **任务背景**：当前正在执行的任务、目标与范围
- **客观证据**（📌 仅包含可验证的事实）：
  - 命令输出：完整的错误信息、日志
  - 代码片段：实际文件内容，带文件路径和行号
  - 测试结果：失败的断言、堆栈跟踪
  - 配置内容：实际配置文件片段
- **我的推断**（⚠️ 明确标注为待验证假设）：
  - 列出 Claude Code 的分析结论
  - 标注每个推断的把握度（高/中/低）
  - 说明推断依据（基于哪些证据）
- **不确定点**（🤔 需要你帮助验证）：
  - 列出分析中的疑点
  - 指出可能存在错误理解的地方

### 问题
- **明确的疑问点**：需要 Codex 解答的具体问题
- **备选方案**：已识别的可能解决方案，需要评估优劣

### 期望
- **输出格式**：期望返回判断（是/否）、建议（推荐方案）、还是代码示例
- **决策标准**：基于什么标准进行判断（性能/可读性/兼容性/风险）

### 示例（体现证据与推断分离）

```markdown
## 上下文
### 任务背景
修复 `packages/config-bundle/src/Service/ConfigHelper.php` 的 PHPStan 错误

### 客观证据（📌 事实）
- **PHPStan 错误**：
  ```
  Method ConfigHelper::getBool() calls deprecated method get()
  Line 42: return $this->get($key) === '1';
  ```
- **相关代码**：
  ```php
  // ConfigHelper.php:40-45
  public function getBool(string $key): bool
  {
      return $this->get($key) === '1';  // get() 已标记为 @deprecated
  }

  // ConfigHelper.php:15-20
  private function get(string $key): string
  {
      return $this->getSystemConfig()[$key] ?? '';
  }
  ```

### 我的推断（⚠️ 待验证）
- **推断1**（把握度：中）：可以直接内联 `get()` 的实现
  - 依据：`get()` 只是简单的数组访问包装
- **推断2**（把握度：低）：性能影响可忽略
  - 依据：假设 `getSystemConfig()` 有缓存，但未验证

### 不确定点（🤔 需要验证）
1. `getSystemConfig()` 是否每次都查询？还是有缓存机制？
2. 是否有其他地方依赖 `get()` 方法（虽然已废弃）？
3. 备选方案：
   - 方案A：`return ($this->getSystemConfig()[$key] ?? '') === '1';`
   - 方案B：保留 `get()` 但移除 @deprecated 标记

## 问题
1. **方案选择**：应该选择方案A直接内联，还是有更好的方案？
2. **性能验证**：`getSystemConfig()` 的调用开销如何？需要担心重复调用吗？
3. **依赖检查**：如何确认没有其他代码依赖已废弃的 `get()` 方法？

## 期望
1. 帮我验证"不确定点"中的假设是否正确
2. 基于验证结果，推荐最佳方案并说明理由
3. 指出我分析中可能存在的错误理解
```

## 操作步骤

### 基础流程
1. **协作预检**
   - 使用可用命令（如 `list_mcp_resources`）确认 Codex MCP 工具处于可用状态。
   - 若检测失败，立即记录阻塞并通知干系人，暂停向 Codex 发起请求。

2. **构造提问框架**（⚠️ 关键：防止错误传播）
   - **必须**按照"证据与推断分离"原则组织信息：
     - ✅ 客观证据：仅提供可验证的事实（命令输出、代码片段、错误信息）
     - ⚠️ 我的推断：明确标注为"待验证假设"，并说明把握度
     - 🤔 不确定点：主动列出可能存在的错误理解
   - **禁止**将未验证的推断当作"已知事实"传递

3. **发起会话**
   - 调用 `codex`（`mcp__codex__codex`）并提交构造好的 `prompt`；必要时设置 `approval-policy`、`sandbox` 等参数。
   - 记录返回的 `conversationId`，用于后续续问或审计。

4. **多轮验证**（🔄 防止错误固化）
   - **第一轮（上下文验证）**：
     ```
     请先验证我提供的"客观证据"是否完整，"我的推断"是否合理？
     指出我可能遗漏的证据或错误的理解。
     ```
   - **第二轮（深入问题）**：
     - 基于 Codex 纠正后的理解，继续深入问题
     - 使用 `codex-reply` 携带 `conversationId` 续问

5. **独立验证**（📋 验证 Codex 建议）
   - **禁止**直接采纳建议，必须通过以下方式验证：
     - 运行相关命令确认行为
     - 编写测试用例验证逻辑
     - 查阅文档核实假设
   - 验证失败时，回到第4步重新续问

6. **记录与同步**
   - 在计划、Runbook 或变更记录中标注"`MCP 协作`"，列出：
     - 调用命令与 `conversationId`
     - 原始问题与 Codex 建议
     - **验证结果**：采纳/部分采纳/未采纳，附验证证据
   - 未采纳需说明原因与替代方案

## 错误检测机制

### 自检清单（构造提问框架前）
在向 Codex 提问前，必须完成以下自检：

| 检查项 | 问题 | ✅ 通过标准 | ❌ 风险信号 |
|-------|------|------------|------------|
| 证据完整性 | 我提供的证据是原始输出吗？ | 包含完整命令输出、文件路径、行号 | 只有概括性描述 |
| 推断标注 | 我区分了事实和推测吗？ | 明确标注"我的推断"和把握度 | 将推测当作事实 |
| 不确定点 | 我列出了可能错误的地方吗？ | 主动列出3+个疑点 | 没有不确定点 |
| 过早结论 | 我是否基于不完整信息下结论？ | 承认信息不足 | 声称已经理解全貌 |
| 假设验证 | 我的分析基于哪些未验证的假设？ | 列出所有关键假设 | 假设当作事实 |

### 危险信号识别
如果出现以下情况，**必须**重新组织提问框架：

1. **过度自信**：
   - ❌ "我确定问题是X"
   - ✅ "我推断问题是X（把握度：中），因为...,但需要验证..."

2. **缺乏证据**：
   - ❌ "根据经验，这个方法应该..."
   - ✅ "我查看了代码（附代码片段），该方法实际上..."

3. **忽略复杂性**：
   - ❌ "这是个简单问题，只需要..."
   - ✅ "表面看起来简单，但可能涉及...,需要验证..."

### 纠错示例

**❌ 错误示例（容易传播错误）：**
```markdown
## 上下文
我发现 `ConfigHelper::get()` 方法被标记为废弃，这个方法是用来获取配置的。
我认为应该直接内联它的实现。

## 问题
我的方案是否正确？
```
**问题**：将"获取配置"这个推断当作事实；没有提供原始代码；假定内联是最佳方案。

**✅ 正确示例（防止错误传播）：**
```markdown
## 上下文
### 客观证据
- PHPStan 错误：`Method calls deprecated get()`
- 代码（ConfigHelper.php:15-20）：
  ```php
  private function get(string $key): string {
      return $this->getSystemConfig()[$key] ?? '';
  }
  ```

### 我的推断（⚠️ 待验证）
- **推断1**（把握度：高）：`get()` 是简单包装
  - 依据：代码只有一行
- **推断2**（把握度：低）：可以安全内联
  - 依据：**未验证是否有缓存、是否有副作用**

### 不确定点
1. `getSystemConfig()` 是否每次查询？
2. 是否有测试依赖 `get()` 的行为？

## 问题
1. 帮我验证推断2的假设
2. 是否有我遗漏的风险？
```

## 失败与降级
- MCP 工具不可用或结果不可靠：记录问题并启动人工评审、线下同步等备用方案，必要时创建例外卡。
- 会话仍无法产出可执行结论：检查提问框架是否缺失信息，补齐后再次协作；若依旧失败，升级到负责人判断。
- 高风险建议未经验证禁止直接落地，需先制定回滚方案并获得批准。
- **检测到错误传播**：立即终止当前会话，重新构造提问框架（使用"错误检测机制"自检），启动新会话。

## 验证清单

### 提问前自检
- [ ] 是否完成"错误检测机制"中的5项自检？
- [ ] 是否明确区分了"客观证据"和"我的推断"？
- [ ] 是否列出了至少3个"不确定点"？
- [ ] 是否避免将未验证的假设当作事实？

### 协作过程验证
- [ ] 是否满足触发条件（把握度<80%、高风险、跨模块）？
- [ ] 第一轮是否请求 Codex 验证上下文理解？
- [ ] 提问框架、会话记录、`conversationId` 是否完整记录？

### 结果验证
- [ ] Codex 建议是否通过独立验证（命令/测试/文档）？
- [ ] 是否在计划或结论中引用 Codex 建议并标注来源？
- [ ] 是否记录了验证结果（采纳/部分采纳/未采纳）？
- [ ] 未采纳时是否说明原因与替代方案？

## 提问框架模板库

为常见场景提供标准化的提问框架模板，提升协作效率。

### 模板 1：批次划分与优先级

```markdown
## 上下文
我正在修复 `<目标路径>` 的 <工具名称> 问题，遇到以下复杂情况：

### 基本信息
- **目标包**：<包名/模块名>
- **错误数量**：<数量> 个
- **测试失败数量**：<数量> 个（<总数> 个测试中）

### 核心约束
- <约束1：如 PHPStan 要求使用集成测试，不允许降级为单元测试>
- <约束2：如需要遵循业务优先原则>
- <约束3：如提交范围限制在指定目录>

### 错误分类概览
1. **类别1**：<描述> (<数量>个)
2. **类别2**：<描述> (<数量>个)
...

## 问题
1. **修复优先级建议**：面对 <总数> 个错误，应该如何分批次修复？考虑：
   - 哪些错误可以自动化批量修复？
   - 哪些错误互相依赖需要一起修复？
   - 哪些错误风险最高应优先处理？

2. **并发修复策略**：用户要求"使用子代理、多任务来并发处理问题"，哪些错误类别适合并发修复？

## 期望
请给出：
1. **修复批次划分**：将错误分为 3-5 个批次，说明每批次的目标和依赖关系
2. **每批次的具体策略**：修复方法、预期影响、回归验证重点
3. **风险评估**：每批次的风险等级和回滚策略
```

### 模板 2：复杂度重构策略

```markdown
## 上下文
我正在执行批次三：复杂度与结构重构。已完成批次一（<描述>）和批次二（<描述>），现在面对复杂度超限问题。

### 复杂度问题统计
1. **<文件名>**
   - 第 <行号> 行：类/方法复杂度 <实际值>（限制 <限制值>）
   - 具体问题：<描述复杂度来源>

### 核心约束
- 这是 <类型> 库，修改可能影响 <影响范围>
- 需要保持业务逻辑完全一致
- 修改后必须通过现有 <测试类型> 测试

## 问题
1. **重构策略选择**：面对复杂度超限，应该：
   - A) 提取私有方法降低单个方法复杂度
   - B) 引入协作对象（如 Visitor、Strategy 模式）
   - C) 重新组织条件分支（如提前返回、卫语句）
   - D) 混合使用以上策略

2. **重构优先级**：应该优先重构哪些文件？考虑：
   - 类复杂度 vs 方法复杂度
   - 哪些重构风险更低？

3. **具体重构建议**：对于 <具体类名>（复杂度 <值>），你建议：
   - 拆分成多个小类？还是提取私有方法？
   - 具体可以怎么拆分？

## 期望
请给出：
1. **重构优先级排序**：<N> 个超限点的处理顺序
2. **每个文件的重构策略**：具体使用什么模式/技巧
3. **测试验证清单**：每次重构后必须执行的验证步骤
4. **风险评估与回滚方案**：哪些重构风险最高，如何回滚
```

### 模板 3：方案选择与权衡

```markdown
## 上下文
我正在 <任务描述>，遇到以下技术决策：

### 当前情况
- **问题**：<具体问题描述>
- **影响范围**：<模块/文件/功能>
- **现有证据**：<已收集的数据、测试结果等>

### 备选方案
**方案 A**：<方案描述>
- 优点：<列出优点>
- 缺点：<列出缺点>
- 风险：<潜在风险>

**方案 B**：<方案描述>
- 优点：<列出优点>
- 缺点：<列出缺点>
- 风险：<潜在风险>

**方案 C**（如有）：<方案描述>
- 优点：<列出优点>
- 缺点：<列出缺点>
- 风险：<潜在风险>

## 问题
1. 应该选择哪个方案？基于什么标准（性能/可读性/可维护性/风险）？
2. 是否有第四种方案我没有考虑到？
3. 选定方案后需要注意什么？

## 期望
请给出：
1. **明确的方案选择**：推荐方案及理由
2. **实施注意事项**：关键步骤和验证点
3. **潜在问题预警**：可能遇到的问题及应对策略
```

### 模板 4：测试失败诊断

```markdown
## 上下文
我正在修复测试失败，遇到以下情况：

### 测试基线
- **修复前**：<总数> 个测试，<失败数> 个失败
- **修复后**：<总数> 个测试，<失败数> 个失败
- **变化**：<增加/减少> <数量> 个失败

### 客观证据（📌 事实）
- **测试文件**：<文件路径>
- **当前代码**（第 X-Y 行）：
  ```php
  <实际测试方法代码>
  ```
- **错误信息**：
  ```
  <完整错误堆栈>
  ```
- **已成功修复的类似代码**（如有）：
  ```php
  <成功案例的代码>
  ```

### 我的推断（⚠️ 待验证）
1. **推断1**（把握度：X）：<推断内容>
   - 依据：<证据>
   - 可能原因：<分析>

### 不确定点（🤔 需要验证）
1. 为什么相同的修复方式在 X 成功，在 Y 失败？
2. 错误堆栈指向第 N 行，是否意味着行号不匹配？
3. 是否应该修改断言方式？
4. 是否有缓存或自动加载问题导致旧代码运行？

### 已尝试的修复
1. <修复尝试1>：<结果>
2. <修复尝试2>：<结果>

## 问题
1. 为什么这个修复方法不起作用？
2. 是否有其他方式可以修复这个错误？
3. 我应该如何调试这个问题？

## 期望
1. 帮我分析根本原因
2. 提供修复建议
3. 解释为什么同样的代码在不同测试中表现不同
```

### 模板使用指南

1. **选择合适的模板**：根据当前场景选择最接近的模板
2. **填充具体信息**：用实际数据替换模板中的占位符
3. **调整结构**：根据实际情况增删问题或期望
4. **保持完整性**：确保"上下文-问题-期望"三部分都完整
5. **附加证据**：必要时附加代码片段、错误日志、测试结果
