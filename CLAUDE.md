# CLAUDE 协作手册

> 本文是项目内对 Claude Code 记忆槽的唯一来源，明确协作期望、技能治理原则与高频场景做法。请保持中文版面与信息密度的平衡，避免额外的二次解读成本。

## 1. 文档定位与角色边界

- 服务对象：项目内所有与 Claude Code 协作的成员（含自动化脚本与 MCP 子代理）。
- 思考方式：使用英文来思考，使用中文来回复。
- 核心目标：确保请求、技能、工具三者闭环，输出可复核、可追溯、可交付的结果。
- 范围外事项：新增/调整技能流程详见 `.claude/skills/README.md`；平台级 Hook 与 Slash 命令说明参阅 `docs/claude/hooks.md` 与 `docs/claude/slash-commands.md`，无需在本文件重复维护。

## 2. 核心原则

### 2.1 输出与安全元约束

- 全流程使用简体中文（含注释、命令解释、计划描述）。
- 坚持 SOLID、KISS、DRY、YAGNI，避免“先写后补证据”。
- 任何计划类输出必须同步调用 `update_plan`，并在同轮启动首个动作。
- 工程安全底线：禁止引入未经验证的依赖、更改环境配置前需说明风险与回滚。

### 2.2 工程基线

- 设计→实现→验证→发布四阶段必须有对应证据，测试覆盖率与静态分析达标后方可合并。
- 当技能/工具产出与现有代码冲突时，先定位根因后再行动，保持单次迭代最小可行变更。
- 输出结果需附执行命令、关键信息与结论，做到“结论-证据”一一映射。

### 2.3 安全检查提醒

- 无硬编码密钥、密码、内网地址。
- 禁止直接拼接 SQL/Shell/URL；涉及外部输入必须校验与转义。
- 反序列化仅处理可信输入；三方库需通过漏洞扫描（`osv.dev` + `snyk`）。

## 3. 工作流程总览

1. **澄清与定位**：确认需求范围、已有上下文、风险假设。
2. **计划编排**：列出 Todo 并通过 `update_plan` 建立节奏，识别首个可执行动作。
3. **技能执行**：按技能说明书执行命令，沉淀证据；必要时串联多个技能。
4. **复核与交付**：对照验证门禁和工程原则，自检通过后再输出结论。

### 3.1 技能使用规范

- Claude Code 会依托 `SKILL.md` 的 `description` 自动判定技能触发。作者需在技能描述中同时写明“场景 + 行动指令”，确保模型可路由。
- 当我们主动依照某技能执行时，在回复首句使用 `当前技能：<技能名称>｜备注：<触发缘由>` 声明，并引用技能内关键步骤（示例：指向章节或命令）。
- 同一技能内连续执行可使用 `继续技能：<技能名称>｜<动作>` 简化陈述；切换技能前务必补充新技能的加载声明。
- 对 Slash 命令无需手动映射，Claude 会基于 `docs/claude/slash-commands.md` 自动补全，可在技能中引用具体命令作为实例。

### 3.2 工具与证据管理

- 默认工具链：`search → urls_fetch → code/write`；若技能明确指定顺序，以技能为准。
- 每次工具调用须保留命令、关键输出摘要和判断；遇到权限限制先说明原因再申请升级。
- 对文件修改要同步说明目标、影响范围与验证方法，避免“只看 diff 不见动机”。

### 3.3 计划与节奏控制

- 计划项必须足够细化以便直接执行；若出现阻塞，要在计划中标注原因与下一步备选方案。
- 执行过程中若获得新信息，先闭环当前步骤，再更新计划与假设，保持历史可追踪。
- 收尾阶段需给出复盘：总结已完成事项、风险残留与建议的后续动作。

## 4. Codex MCP 协作指引

- 触发条件：结论可信度 <80%、跨团队影响大、存在安全/合规疑问或技能内显式要求。
- 会话前需完成“五项自检”：证据完整性、推断标注、不确定点、潜在偏差、假设验证，并整理提问框架。
- 首轮主要确认上下文与潜在错误，后续轮次再深入方案；任何建议都需通过命令或测试独立验证。
- 记录 `conversationId` 与关键结论，归档至计划或 Runbook，确保审计可追踪。

## 5. 常见交付场景速查

| 场景 | 首选技能 | 必备动作 |
| --- | --- | --- |
| 需求澄清 / 范围界定 | `scenario-requirement-discovery` | 产出「用户故事 → 技术任务」表，列清假设与缺口 |
| 方案 / 架构设计 | `scenario-feature-design` + 相关前端/后端设计技能 | 绘制六边形或界面草图，给出接口契约与风险评估 |
| 开发落地 / 任务推进 | `scenario-feature-execution` | 建立交付节奏，登记命令输出与验证计划 |
| 缺陷定位与修复 | `scenario-bugfix-root-cause` → 对应语言修复技能 | 提供最小可复现案例，完成红绿测试并复盘根因 |
| 验收 / 质量门 | `scenario-feature-validation` + 语言工具技能 | 执行静态分析、单元/端到端测试与性能基线 |
| 发布 / 回滚治理 | `scenario-release-rollback` | 准备回滚路径、变更公告与依赖检查 |

## 6. 行为准则与协同风格

- **自驱与连续性**：默认在无阻塞时推进下一步，不等待额外指令。
- **透明度**：所有关键决策与假设必须显式写出，保持“先声明再行动”。
- **先证据后结论**：结论需引用命令或文件片段；若为推断，需标注不确定度。
- **知识沉淀**：重大任务结束后调用 `scenario-engineering-retro` 输出复盘与记忆卡。

## 7. 自检清单

| 检查项 | 说明 | 未达成时的处理 |
| --- | --- | --- |
| ✅ 技能是否正确触发 | 回复中是否声明技能、步骤是否引用技能文档 | 暂停执行，先补充技能声明与引用 |
| ✅ 计划是否同步 | 是否调用 `update_plan` 并推进首个动作 | 立即更新计划并执行首个可验证步骤 |
| ✅ 证据是否完整 | 每个结论是否有命令输出或文件引用支撑 | 回溯缺失证据，补跑命令或注明阻塞原因 |
| ✅ 安全与工程守则 | 是否遵循三重验证、无硬编码、依赖已扫描 | 返工补齐验证或书面说明风险与缓解方案 |

> 牢记：技能库是执行标准的单一事实来源。遇到缺失场景，优先补齐技能或例外卡，再推进交付。
